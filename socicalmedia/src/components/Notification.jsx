import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
import '../style/Notification.css';
import Sidebar from "../components/Sidebar";
import Header from "../components/Header";

const NotificationComponent = () => {
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isNotificationsEnabled, setIsNotificationsEnabled] = useState(true);
  const [loading, setLoading] = useState(false);
  const [statusMessage, setStatusMessage] = useState('');
  const navigate = useNavigate();
  
  const user = JSON.parse(localStorage.getItem('user'));
  const userId = user?.id;

  const fancyTextRef = useRef(null);
  const text = "Th√¥ng b√°o";
  let index = 0;

  useEffect(() => {
    if (!fancyTextRef.current) return;

    const typeText = () => {
      if (index < text.length) {
        const span = document.createElement("span");
        span.textContent = text[index];
        span.style.setProperty('--i', index);
        fancyTextRef.current.appendChild(span);
        index++;
        setTimeout(typeText, 70);
      }
    };

    // Clear previous content
    fancyTextRef.current.innerHTML = '';
    index = 0;
    typeText();
  }, []);

  useEffect(() => {
    if (!userId) {
      setStatusMessage('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem th√¥ng b√°o.');
      navigate('/login');
      return;
    }

    const fetchNotifications = async () => {
      setLoading(true);
      try {
        const response = await axios.get(`/notifications/${userId}`);
        setNotifications(response.data);
        setUnreadCount(response.data.filter(n => !n.is_read).length);
        setStatusMessage('');
      } catch (error) {
        console.error('Error fetching notifications:', {
          message: error.message,
          status: error.response?.status,
          data: error.response?.data,
        });
        setStatusMessage(
          error.response?.status === 404
            ? 'Kh√¥ng t√¨m th·∫•y th√¥ng b√°o.'
            : 'C√≥ l·ªói x·∫£y ra khi t·∫£i th√¥ng b√°o.'
        );
      } finally {
        setLoading(false);
      }
    };

    fetchNotifications();
    const interval = setInterval(fetchNotifications, 30000);
    return () => clearInterval(interval);
  }, [userId, navigate]);

  const formatTime = (createdAt) => {
    const date = new Date(createdAt);
    const now = new Date();
    const diffInSeconds = Math.floor((now - date) / 1000);
    if (diffInSeconds < 60) return `${diffInSeconds} gi√¢y tr∆∞·ªõc`;
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} ph√∫t tr∆∞·ªõc`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} gi·ªù tr∆∞·ªõc`;
    return date.toLocaleString('vi-VN', { dateStyle: 'short', timeStyle: 'short' });
  };

  const markAsRead = async (id) => {
    setLoading(true);
    try {
      await axios.post(`/notifications/${id}/read`, { user_id: userId });
      setNotifications(notifications.map(notification =>
        notification.id === id ? { ...notification, is_read: true } : notification
      ));
      setUnreadCount(prev => prev - 1);
      setStatusMessage('Th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u ƒë√£ ƒë·ªçc.');
    } catch (error) {
      console.error('Error marking notification as read:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      setStatusMessage('C√≥ l·ªói khi ƒë√°nh d·∫•u th√¥ng b√°o ƒë√£ ƒë·ªçc.');
    } finally {
      setLoading(false);
    }
  };

  const markAllAsRead = async () => {
    setLoading(true);
    try {
      await axios.post('/notifications/mark-all-read', { user_id: userId });
      setNotifications(notifications.map(notification => ({ ...notification, is_read: true })));
      setUnreadCount(0);
      setStatusMessage('T·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u ƒë√£ ƒë·ªçc.');
    } catch (error) {
      console.error('Error marking all notifications as read:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      setStatusMessage('C√≥ l·ªói khi ƒë√°nh d·∫•u t·∫•t c·∫£ th√¥ng b√°o ƒë√£ ƒë·ªçc.');
    } finally {
      setLoading(false);
    }
  };

  const toggleNotifications = async () => {
    if (!userId) {
      setStatusMessage('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t th√¥ng b√°o.');
      navigate('/login');
      return;
    }
    setLoading(true);
    try {
      const response = await axios.post('/notifications/settings', {
        user_id: userId,
        enabled: !isNotificationsEnabled,
      });
      console.log('Toggle notifications response:', response.data);
      setIsNotificationsEnabled(!isNotificationsEnabled);
      setStatusMessage(isNotificationsEnabled ? 'ƒê√£ t·∫Øt th√¥ng b√°o' : 'ƒê√£ b·∫≠t th√¥ng b√°o');
    } catch (error) {
      console.error('Error toggling notifications:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
        request: error.request,
      });
      setStatusMessage(
        error.response?.status === 404
          ? 'Kh√¥ng t√¨m th·∫•y endpoint c√†i ƒë·∫∑t th√¥ng b√°o.'
          : error.response?.status === 401
          ? 'Kh√¥ng c√≥ quy·ªÅn thay ƒë·ªïi c√†i ƒë·∫∑t th√¥ng b√°o.'
          : 'C√≥ l·ªói khi thay ƒë·ªïi c√†i ƒë·∫∑t th√¥ng b√°o.'
      );
    } finally {
      setLoading(false);
    }
  };

  const deleteNotification = async (id) => {
    setLoading(true);
    try {
      await axios.delete(`/notifications/${id}`, { data: { user_id: userId } });
      setNotifications(notifications.filter(notification => notification.id !== id));
      setUnreadCount(prev => prev - 1);
      setStatusMessage('Th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c x√≥a.');
    } catch (error) {
      console.error('Error deleting notification:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      setStatusMessage('C√≥ l·ªói khi x√≥a th√¥ng b√°o.');
    } finally {
      setLoading(false);
    }
  };

  const handleNotificationClick = (notification) => {
    if (notification.notifiable_id) {
      if (
        notification.notification_content.includes('b√¨nh lu·∫≠n') ||
        notification.notification_content.includes('th·∫£ c·∫£m x√∫c') ||
        notification.notification_content.includes('m·ªõi tr√™n b√†i vi·∫øt')
      ) {
        navigate(`/posts/${notification.notifiable_id}`, {
          state: { commentId: notification.comment_id || null },
        });
      } else if (notification.notification_content.includes('theo d√µi')) {
        navigate(`/users/${notification.notifiable_id}`);
      }
      markAsRead(notification.id);
    }
  };

  return (
    <div className="container">
      <Header />
      <Sidebar />
      <div className="notifications-wrapper">
        <div className="notifications-container">
          <div className="notifications-header">
            <div className="fancy-container">
              <div className="fancy-text" ref={fancyTextRef}></div>
              {unreadCount > 0 && <span className="unread-badge">{unreadCount}</span>}
            </div>
            <div className="header-actions">
              <button
                onClick={markAllAsRead}
                className="action-btn mark-all-btn"
                disabled={loading}
              >
                {loading ? 'ƒêang x·ª≠ l√Ω...' : 'ƒê√°nh d·∫•u t·∫•t c·∫£ ƒë√£ ƒë·ªçc'}
              </button>
              <button
                onClick={toggleNotifications}
                className="action-btn toggle-btn"
                disabled={loading}
              >
                {loading ? 'ƒêang x·ª≠ l√Ω...' : isNotificationsEnabled ? 'T·∫Øt th√¥ng b√°o' : 'B·∫≠t th√¥ng b√°o'}
              </button>
            </div>
          </div>
          {statusMessage && <div className="status-message">{statusMessage}</div>}
          {loading && <div className="loading-spinner">‚è≥ ƒêang t·∫£i...</div>}
          <ul className="notifications-list">
            {notifications.length > 0 ? (
              notifications.map(notification => (
                <li
                  key={notification.id}
                  className={`notification-item ${notification.is_read ? 'read' : 'unread'}`}
                  onClick={() => handleNotificationClick(notification)}
                >
                  <div className="notification-content">
                    <div className="notification-icon">
                      {notification.notification_content.includes('th·∫£ c·∫£m x√∫c') ? (
                        {
                          like: 'üëç',
                          love: '‚ù§Ô∏è',
                          haha: 'üòÇ',
                          wow: 'üò≤',
                          sad: 'üò¢',
                          angry: 'üò°',
                        }[notification.notification_content.match(/th·∫£ c·∫£m x√∫c (\w+)/)?.[1]] || 'üòä'
                      ) : notification.notification_content.includes('b√¨nh lu·∫≠n') ? 'üí¨' : 
                        notification.notification_content.includes('theo d√µi') ? 'üë§' : 'üîî'}
                    </div>
                    <div className="notification-text">
                      <p>{notification.notification_content}</p>
                      <span className="notification-time">{formatTime(notification.created_at)}</span>
                    </div>
                  </div>
                  <div className="notification-actions">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        markAsRead(notification.id);
                      }}
                      className="action-btn mark-read-btn"
                      disabled={loading}
                    >
                      {notification.is_read ? 'ƒê√£ ƒë·ªçc' : 'ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc'}
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteNotification(notification.id);
                      }}
                      className="action-btn delete-btn"
                      disabled={loading}
                    >
                      X√≥a
                    </button>
                  </div>
                </li>
              ))
            ) : (
              <p className="no-notifications">Kh√¥ng c√≥ th√¥ng b√°o m·ªõi</p>
            )}
          </ul>
        </div>
      </div>
    </div>
  );
};

export default NotificationComponent;